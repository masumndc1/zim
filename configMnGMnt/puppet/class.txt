

...
... class is omnibus in puppet
... example: https://github.com/masumndc1/puppet-infra.git
...

~/Documents/github/puppet-infra
❯ ls
 gt.py   manifests   metadata.json   README.md   templates

❯ lt manifests
 manifests
├──  hostname.pp
├──  init.pp
├──  messages.pp
├──  neovim.pp
├──  packages.pp
├──  partition.pp
├──  pkg_ver.pp
├──  sudo.pp
├──  summary.pp
├──  update.pp
├──  upgrade.pp
└──  zsh.pp
❯ cd manifests
❯ ls
 hostname.pp   messages.pp   packages.pp    pkg_ver.pp   summary.pp   upgrade.pp
 init.pp       neovim.pp     partition.pp   sudo.pp      update.pp    zsh.pp

$ cat init.pp
class infra {
  include infra::packages
  include infra::partition
  include infra::sudo
  include infra::summary
  include infra::zsh
}

... then content of packages.pp

❯ cat packages.pp
class infra::packages {
  $_packages = lookup('packages')

  if ($facts['osfamily'] == 'Debian'
    or $facts['osfamily'] == 'Redhat') {
    $_packages.each | $pkg | {
      package { $pkg:
        ensure => 'installed',
        tag    => 'pkg',
      }
    }
  }
}

... note here, how we have initialize a class

❯ cat summary.pp
class infra::summary (
  $_hostname = $facts['hostname'],
  $_arch = $facts['os']['architecture'],
  $_uptime = $facts['system_uptime']['uptime'],
  $_family = $facts['os']['family'],
  $_name = $facts['os']['name'],
  $_release = $facts['os']['release']['full'],
  $_distro = $facts['os']['distro']['codename']
) {
  file { "/tmp/summary.txt":
    content => template('infra/summary.erb')
  }
}

... and finally a defined class

❯ cat pkg_ver.pp
define infra::pkg_ver (
  $pkg,
) {
  exec { 'version':
    command => "${pkg} --version",
    path => '/usr/bin:/snap/bin',
    provider => shell,
    logoutput => 'true',
  }
}

... calling, defined class require parameter to be passed.
... and defined calss is reusable thoughout the manifest file
... multiple times.

... calling class: how to call a class:
... please note here, in the above, when creating a class,
... inside the class, we declare variables like $pkg. On the
... other hand, when to call that class, we pass the variables
... without $ sign infront of them. like below. variable pkg
... does not have $ infront of it.

class { 'infra::pkg_ver':
  pkg => 'vim',
}

... another example of a defined class and calling it.

define mymodule::vhost($port, $docroot) {
  file { "/etc/apache2/sites-available/${title}.conf":
    ensure  => present,
    content => "Listen ${port}\nDocumentRoot ${docroot}\n",
  }
}

.. and calling that defined class

mymodule::vhost { 'example.com':
  port    => 80,
  docroot => '/var/www/html',
}

... another example of defined class:
... note: in the defined class, title will be replace by
... title, "example.com" when mymodule::vhost is called,
... in this case, 'example.com'
...
... also, note here, passing variable to define class
... does not have $ sign infront of port and docroot.
... these are treated as string not variable reference.
... this is completely different than in class.

define mymodule::vhost($port, $docroot) {
  file { "/etc/vhosts/${title}.conf":
    content => "Listen ${port}\nDocRoot ${docroot}\n",
  }
}

mymodule::vhost { 'example.com':
  port    => 8080,
  docroot => '/var/www/example',
}

... summary:
... Class, declared with "include" or class { }
... Defined classes are declared like a resource:
...     mymodule::thing { 'title': params }
...
... we can call a class and a defined class in a same manifests file
...

class dummy {
  # class definition
  include mymodule::apache

  # define class
  mymodule::vhost { 'myapp.local':
    port    => 8080,
    docroot => '/srv/myapp',
  }
}

... when we need to pass value to a class variable, we do that following
... say for example hieradata. in common.yaml we define like following,
... To provide data for a module’s input, the data must be named modulename::param
... name. So start by defining the restrict and interface options in the YAML file:

---
# common.yaml file

ntp::interfaces:
- '127.0.0.1'
# which nodes can connect
ntp::restrict:
- 'default kod nomodify notrap nopeer noquery'
- '-6 default kod nomodify notrap nopeer noquery'
- '127.0.0.1'
- '-6 ::1'
- '192.168.250.0/24'
- '-6 fe80::'

... subclass:
... another way of chaining classes under class (it was used old age a lot,
... this is not recommended way of doing, now a days but still used, rather
... use include keyword) is subclass.
...

# manifests/init.pp
class puppet (
  # common variables for all Puppet classes
  String $version = 'latest',
  String $loglevel = 'warning',
) {
  # no resources in this class
}

# manifests/agent.pp
class puppet::agent (
  # input parameters specific to agent subclass
  Enum['running','stopped'] $status = 'running',
  Boolean $enabled, # required parameter
) inherits puppet {
  # here we are getting parameters from upper/parent class
  # from where it inherits
  # all of the resources previously defined
}

# manifests/server.pp
class puppet::server() {
  # this is a independent class
  # this is under the parent class puppet
  # but not inheriting anything
}

... ordering:
...

service { 'puppet':
  ensure => $status,
  enable => $enabled,
  subscribe => Package['puppet-agent'],
  after => Class['rsyslog'],
}

... this service puppet will be enabled after the class['rsyslog'] works.
